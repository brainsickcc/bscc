-- -*- auto-fill-mode: nil; indent-tabs-mode: nil; -*-

optpragmas
{
-- Copyright Â© 2012 Iain Nicol

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generation of the Intermediate Representation (IR).

-- This comment separates above doc comment and UUAGC-inserted comment
}

MODULE {Bscc.Codegen.Ir}
-- Exports
{
codegen,
x86_stdcallcc
}
-- Imports
{
import Debug.Trace (trace)
import Bscc.Ast.WithSem
import Bscc.Symbol.Name

import Control.Exception (throwIO)
import Control.Lens.Operators ((&), (<&>))
import Control.Monad ((>=>))
import Control.Monad.Trans.Error (ErrorT, runErrorT)
import qualified Data.ByteString as B
import qualified Data.Char as Char
import Data.Foldable (toList)
import Data.Maybe (catMaybes, fromJust, isJust)
import Data.Monoid ((<>))
import Data.Sequence ((<|), (|>)) -- FIXME can I take this from monoid?
import qualified Data.Sequence as Seq
import qualified Data.Set as Set
import qualified Data.Text as T
import Data.Text.Encoding (encodeUtf16BE)
import Data.Word (Word, Word8, Word16)
import qualified LLVM.General.AST as A
import LLVM.General.AST.Attribute (ParameterAttribute)
import LLVM.General.AST.AddrSpace (AddrSpace (AddrSpace))
import qualified LLVM.General.AST.CallingConvention as CC
import qualified LLVM.General.AST.Constant as C
import qualified LLVM.General.AST.Global as G
import qualified LLVM.General.AST.Instruction as I
import LLVM.General.AST.Instruction (Named ((:=)))
import qualified LLVM.General.AST.Linkage as L
import qualified LLVM.General.AST.Name as N
import qualified LLVM.General.AST.Operand as O
import qualified LLVM.General.AST.Float as Float
import qualified LLVM.General.AST.Type as T
import qualified LLVM.General.AST.Visibility as V
import Prelude hiding (FilePath)
import System.Path (RelFile, relFile, takeBaseName, (<.>))
}

INCLUDE "../Ast/WithSem.ag"


{
-- | IR code generation.
--
-- The output of this function should be valid if the input came from
-- `Bscc.Sem.semAnalysis'.  Otherwise you should keep a few things in
-- mind to ensure the output here is well behaved:
--
--   * There should be precisely one program entry point between all the
--     modules.  For example, have one Sub Main, and no other Main
--     procedures.
--
--   * Don't feed in any invalid expression trees.  Note that ideally
--     this would be prevented with the use of GADTs.  However, that is
--     not possible because we are using a specific preprocessor (UUAGC)
--     to define the datatypes of, and to process, the trees.
codegen :: SProject               -- ^ AST with type information.
        -> [(A.Module, RelFile)]  -- ^ The `fst' of each list element is
                                  -- IR.  The `snd' is a (recommended)
                                  -- relative path to save it to, if you
                                  -- were to convert it to textual LLVM
                                  -- assembly.
codegen = toList .
          ir_Syn_SProject . (`wrap_SProject` Inh_SProject) . sem_SProject

fromRightErrorTIo :: Show a => ErrorT a IO b -> IO b
fromRightErrorTIo = runErrorT >=> either (throwIO . userError . show) return

x86_stdcallcc :: CC.CallingConvention
x86_stdcallcc = CC.Numbered 64
}

-- FIXME: do I put UNIQUEREF inside Sem, or do I put symbol table inside here?
-- Similarly, FIXME: Sem on IdentExpr needs to refer to the correct variable
-- if there are duplicates (at different scope levels) or similar names; OR
-- Sem on SIdentExpr can do such.  OR IS THAT AN AND???.
-- Support for UNIQUEREF (generating unique numbers, for labels, etc.).
ATTR SModule
     STopLevels STopLevel
     SProcs SProc SInProcStmts SInProcStmt SExprs SExpr SElseIfs SElseIf
     SCases SCase
     SNewProp SNewProps SNewClassHeaderBlock SNewClassHeaderBlocks SNewClassHeader
     [ | counter: Int | ]
SEM SModules
  | Cons  hd.counter = 30000 -- FIXME
{
-- | Function with required named and behaviour, per the UUAGC manual,
-- for UNIQUEREF support.
nextUnique :: Int -> (Int, Int)
nextUnique n = (n + 1, n)
}


-- * Here we have the main, reasonably straightforward (famous last
-- words), section of code for IR generation

ATTR SProject     [ | | ir: {Seq.Seq (A.Module, RelFile)} ]
SEM SProject
  | SProject  lhs.ir = @modules.ir

ATTR SModules     [ | | ir USE {<>} {Seq.empty}:
                          {Seq.Seq (A.Module, RelFile)} ]

-- FIXME [] vs seq
-- TODO where to move this
-- FIXME should we get rid of toplevels with the semed ast?
-- ie sbasmodule should directly have sdims and sprocs, not stoplevels?
ATTR STopLevels   [ | | procs USE {<>} {[]}:
                          {SProcs} ]
ATTR STopLevel    [ | | procs: {SProcs} ]
-- FIXME naming of these is ugly to avoid clash (what, the constructors?)
SEM STopLevel
   | SAttribute  lhs.procs = []
   | SDim  lhs.procs = []
   | SOption  lhs.procs = []
   | SProc  lhs.procs = [@proc.self]

-- TODO: can I merge with other SEM STopLevel?
-- Then wouldn't need that inst nonsense inside SModule
ATTR STopLevels   [ | | otherDecls USE {<>} {Seq.empty}:
                          {Seq.Seq A.Definition} ]
ATTR STopLevel SDim   [ | | otherDecls: {Seq.Seq A.Definition} ]
SEM STopLevel
   | SAttribute  lhs.otherDecls = Seq.empty
   -- FIXME type, alignment
   | SDim -- implicit copy.  or make explicit?
   | SOption  lhs.otherDecls = Seq.empty
   | SProc  lhs.otherDecls = Seq.empty

SEM SDim
  -- FIXME trace
  | SDimConstr  loc.otherDecls2 = [G.GlobalVariable @loc.myname L.Internal V.Default False (AddrSpace 0) False False @ty.ty (@ty.defaultValish & Just) Nothing 8 & A.GlobalDefinition] & Seq.fromList
                lhs.otherDecls = trace ("SDim.otherDecls: " ++ show @loc.otherDecls2) @loc.otherDecls2
                -- loc.nameish : UNIQUEREF counter
                -- loc.name = N.UnName (fromIntegral @loc.nameish)
                loc.myname = raw @name & map Char.toLower & N.Name

ATTR SModule      [ | | ir: {Seq.Seq (A.Module, RelFile)} ]
SEM SModule
  | SBasModule
                inst.procs : SProcs
                inst.procs = @topLevel.procs
                procs.inProject = @lhs.inProject
                procs.inModule = @name
                lhs.ir = [(A.defaultModule
                           {
                             A.moduleDefinitions =
                               @loc.fileLevelDecls <> @procs.definition
                               & toList
                           },
                           takeBaseName @path <.> "ll")
                         ]
                         & Seq.fromList
                loc.fileLevelDecls = (@procs.fileLevelDecls <&> A.GlobalDefinition) <>
                                     @loc.declsUsedNonLocalProcs <> @topLevel.otherDecls
                loc.declsUsedNonLocalProcs =
                {
                  @usedNonLocalProcs.importDeclaration
                  <&> A.GlobalDefinition
                  & Seq.fromList
                }
                inst.usedNonLocalProcs : SProcPrototypes
                inst.usedNonLocalProcs = Set.elems @procs.usedNonLocalProcs
                usedNonLocalProcs.inProject = @lhs.inProject
                usedNonLocalProcs.inModule = @name
  | SForm       inst.procs : SProcs
                inst.procs = @topLevel.procs
                procs.inProject = @lhs.inProject
                procs.inModule = @name
                lhs.ir = [(A.defaultModule
                           {
                             A.moduleDefinitions =
                               @loc.fileLevelDecls <> @procs.definition
                               <> @loc.newForm
                               -- <> @loc.traceit
                               & toList
                           },
                           takeBaseName @path <.> "ll")
                         -- FIXME indentation.
                         -- FIXME form startup should be not be part of every form;
                         -- only the startup form (if there is one)
                         ,@loc.startup
                         ]
                         & Seq.fromList
                loc.fileLevelDecls = (@procs.fileLevelDecls <&> A.GlobalDefinition) <>
                                     @loc.declsUsedNonLocalProcs
                                     <> @topLevel.otherDecls
                loc.declsUsedNonLocalProcs =
                {
                  @usedNonLocalProcs.importDeclaration
                  <&> A.GlobalDefinition
                  & Seq.fromList
                }
                inst.usedNonLocalProcs : SProcPrototypes
                inst.usedNonLocalProcs = Set.elems @procs.usedNonLocalProcs
                usedNonLocalProcs.inProject = @lhs.inProject
                usedNonLocalProcs.inModule = @name
                -- loc.uniqueN : UNIQUEREF counter
                loc.startup = mkStartup ()

                -- loc.traceit = trace ("TRACING: " ++ show @loc.buttonanalysisret)
                --                     (Seq.empty)

                -- loc.propHeaderTrace = trace (show @loc.propHeader) ""
                -- loc.propHeader = 

                -- loc.bar = @buttonanalysis.val
                -- loc.addonebutton =
                --   I.Do (I.Call False x86_stdcallcc []
                --                (C.GlobalReference (T.FunctionType hwnd [iFormPtr] False) (N.Name "AddButton") & O.ConstantOperand & Right)
                --                [(O.LocalReference iFormPtr (N.UnName 11), [])]
                --                [] [])
                loc.buttonsBlock =
                  G.BasicBlock (N.UnName 12)
                    -- (map (const @loc.addonebutton) @firstbutton)
                    -- (addonebuttonandsetcaptionetc @firstbutton.self @buttonsetcaption.operandEtc @buttonsetwidth.operandEtc @buttonsetheight.operandEtc)
                    (toList @header.init)
                    (I.Do (I.Br (N.UnName 999) []))

                loc.retBlock =
                  G.BasicBlock (N.UnName 999)
                    [
                    ]
                    (I.Do (I.Ret (O.LocalReference iFormPtr (N.UnName 11) & Just) []))

                loc.newFormBlocks =
                  [
                    G.BasicBlock (N.UnName 0)
                      [
                      -- Form* f
                      N.UnName 1 := I.Alloca formPtr Nothing 4 []
                      -- TODO: compact numbering (no 2, which was printf)
                      --  = (Form*)malloc(sizeof(Form))
                      -- FIXME hardcoded size
                      -- FIXME what if malloc fails
                      , N.UnName 3 := I.Call False CC.C []
                                        (C.GlobalReference (T.FunctionType i8Ptr [T.i32] False) (N.Name "malloc") & O.ConstantOperand & Right)
                                        [(C.Int 32 8 & O.ConstantOperand, [])]
                                        [] []
                      , N.UnName 4 := I.BitCast (O.LocalReference i8Ptr (N.UnName 3)) formPtr []
                      , I.Do (I.Store False (O.LocalReference formPtrPtr (N.UnName 1)) (O.LocalReference formPtr (N.UnName 4)) Nothing 4 [])
                      -- f->
                      , N.UnName 5 := I.Load False (O.LocalReference formPtrPtr (N.UnName 1)) Nothing 4 []
                      --  IForm_iface
                      , N.UnName 6 := I.GetElementPtr True (O.LocalReference formPtr (N.UnName 5)) [C.Int 32 0 & O.ConstantOperand, C.Int 32 0 & O.ConstantOperand] []
                      -- .lpVtbl
                      , N.UnName 7 := I.GetElementPtr True (O.LocalReference iFormPtr (N.UnName 6)) [C.Int 32 0 & O.ConstantOperand, C.Int 32 0 & O.ConstantOperand] []
                      -- = &form_vbtl;
                      , I.Do (I.Store False
                                      (O.LocalReference iFormVtblPtrPtr (N.UnName 7))
                                      (C.BitCast (C.GlobalReference iFormVtblRef (N.Name "form_vtbl")) iFormVtblPtr & O.ConstantOperand)
                                      -- FIXME remove this dud attempt
                                      -- (C.BitCast (C.GlobalReference (T.StructureType False [iFormLoad, iFormShow]) (N.Name "form_vtbl")) iFormVtblRef & O.ConstantOperand)
                                      Nothing 4 [])
                      -- -- f
                      , N.UnName 8 := I.Load False (O.LocalReference formPtrPtr (N.UnName 1)) Nothing 4 []
                      -- -- ->hwnd
                      , N.UnName 9 := I.GetElementPtr True (O.LocalReference formPtr (N.UnName 8)) [C.Int 32 0 & O.ConstantOperand, C.Int 32 1 & O.ConstantOperand] []
                      -- --  = NULL;
                      , I.Do (I.Store False
                                      (O.LocalReference hwndPtr (N.UnName 9))
                                      (C.Null hwnd & O.ConstantOperand)
                                      Nothing 4 [])
                      -- f
                      , N.UnName 10 := I.Load False (O.LocalReference formPtrPtr (N.UnName 1)) Nothing 4 []
                      -- & ->iForm_iface
                      , N.UnName 11 := I.GetElementPtr True (O.LocalReference formPtr (N.UnName 10)) [C.Int 32 0 & O.ConstantOperand, C.Int 32 0 & O.ConstantOperand] []
                      ]
                      -- return              ;
                      (I.Do (I.Br (N.UnName 12) []))
                  , @loc.buttonsBlock
                  , @loc.retBlock
                  ]
                loc.newForm =
                  [ G.Function L.External V.Default x86_stdcallcc []
                      iFormPtr (N.Name "new_form_codegened") ([], False)
                      [] Nothing 0 Nothing
                      @loc.newFormBlocks
                    & A.GlobalDefinition
                  , iForm, iFormVtbl, hwnd__, malloc, iButton, iButtonVtbl
                  , form -- FIXME: this and hwnd aren't showing up in gened ll
                  , form_load_ref, form_show_ref
                  , form_vtbl
                  , addbtn
                  ]
                  & Seq.fromList

ATTR SNewClassHeader [ | | init: {Seq.Seq (I.Named I.Instruction)} ]
SEM SNewClassHeader
  | SNewClassHeader
      lhs.init = @me.init <> @children.init

ATTR SNewClassHeaderBlocks [ | | init USE {<>} {Seq.empty}: {Seq.Seq (I.Named I.Instruction)} ]
ATTR SNewClassHeaderBlock [ | | init: {Seq.Seq (I.Named I.Instruction)} ]
SEM SNewClassHeaderBlock
  | SNewClassHeaderBlock
       loc.ctlinstridWip : UNIQUEREF counter
       loc.ctlinstrid = N.UnName (fromIntegral @loc.ctlinstridWip)
       loc.create =
         -- FIXME: don't call AddButton if @classname isn't VB.CommandButton!!!!!
         [ @loc.ctlinstrid :=
             I.Call False x86_stdcallcc []
             (C.GlobalReference (T.FunctionType iButtonPtr [iFormPtr] False) (N.Name "AddButton") & O.ConstantOperand & Right)
             [(O.LocalReference iFormPtr (N.UnName 11), [])]
             [] []
         ]
         & Seq.fromList
      loc.setprops = @props.init
      lhs.init = @loc.create <> @props.init

ATTR SNewProps [ ctlinstrid: {N.Name} | | init USE {<>} {Seq.empty}: {Seq.Seq (I.Named I.Instruction)} ]
ATTR SNewProp  [ ctlinstrid: {N.Name} | | init: {Seq.Seq (I.Named I.Instruction)} ]

SEM SNewProp
   | SNewPropSimple
       loc.n1wip : UNIQUEREF counter
       loc.n1 = N.UnName (fromIntegral @loc.n1wip :: Word)
       loc.n2wip : UNIQUEREF counter
       loc.n2 = N.UnName (fromIntegral @loc.n2wip :: Word)
       loc.n3wip : UNIQUEREF counter
       loc.n3 = N.UnName (fromIntegral @loc.n3wip :: Word)
       loc.n4wip : UNIQUEREF counter
       loc.n4 = N.UnName (fromIntegral @loc.n4wip :: Word)
       loc.n5wip : UNIQUEREF counter
       loc.n5 = N.UnName (fromIntegral @loc.n5wip :: Word)
       loc.n6wip : UNIQUEREF counter
       loc.n6 = N.UnName (fromIntegral @loc.n6wip :: Word)
       loc.n7wip : UNIQUEREF counter
       loc.n7 = N.UnName (fromIntegral @loc.n7wip :: Word)
       loc.n8wip : UNIQUEREF counter
       loc.n8 = N.UnName (fromIntegral @loc.n8wip :: Word)
       loc.n9wip : UNIQUEREF counter
       loc.n9 = N.UnName (fromIntegral @loc.n9wip :: Word)
       loc.vtblIdx = let (VtableIndex vtblIdx) = @vtblIdx.self in vtblIdx
       loc.idxish = fromIntegral @loc.vtblIdx
       -- FIXME: this isn't general purpose enough i.e. can only coerce literals not results of binary operators.
       -- TODO: to support such, note that coercion might require some instructions (e.g. alloc and call?); then it would return a N.UnName as opposed to e.g. a simple ast literal.
       -- TODO: share coercion code with e.g. let statement?  call statement?

       loc.param =
         case @ty.self of
           SDouble ->
             case @val.self of
               SDoubleLit val _ ->
                 O.ConstantOperand (C.Float (Float.Double val))
                 & Just
               SIntegerLit val _ ->
                 O.ConstantOperand (C.Float (Float.Double (realToFrac val)))
                 & Just
               _ -> Nothing
           _ -> Nothing
       lhs.init = if (@loc.idxish /= 99999) && (isJust (trace ("loc.param is: " ++ show @loc.param) @loc.param))
                    then
                      [
                        @loc.n1 := I.Alloca iButtonPtr Nothing 4 []
                      , I.Do (I.Store False (O.LocalReference iButtonPtrPtr @loc.n1) (O.LocalReference iButtonPtr @lhs.ctlinstrid) Nothing 4 [])
                      -- button->
                      , @loc.n3 := I.Load False (O.LocalReference iButtonPtrPtr @loc.n1) Nothing 4 []
                      -- lpVtbl
                      , @loc.n4 := I.GetElementPtr True (O.LocalReference iButtonPtr @loc.n3) [C.Int 32 0 & O.ConstantOperand, C.Int 32 0 & O.ConstantOperand] []
                      -- ->
                      , @loc.n5 := I.Load False (O.LocalReference iButtonVtblPtrPtr @loc.n4) Nothing 4 []
                      -- propname at particular index
                      , @loc.n6 := I.GetElementPtr True (O.LocalReference iButtonVtblPtr @loc.n5) [C.Int 32 0 & O.ConstantOperand, C.Int 32 @loc.idxish & O.ConstantOperand] []
                      , @loc.n7 := I.Load False (O.LocalReference iButtonSetWidth @loc.n6) Nothing 4 []
                      -- ready an IButton* to pass as param
                      , @loc.n8 := I.Load False (O.LocalReference iButtonPtrPtr @loc.n1) Nothing 4 []
                      -- ( call )
                      , @loc.n9 := I.Call False x86_stdcallcc []
                                     (O.LocalReference iButtonSetWidth @loc.n7 & Right)
                                     [(O.LocalReference iButtonPtr @loc.n8, [])
                                     , (fromJust @loc.param, []) -- FIXME parameterize
                                     ]
                                     [] []
                      ] & Seq.fromList
                    else
                      Seq.empty
       

{
ptr = flip T.PointerType (AddrSpace 0)
formPtr = T.NamedTypeReference (N.Name "struct.Form")
          & ptr
formPtrPtr = formPtr & ptr -- TODO: get rid of these precomposed variables.  just define a ptrPtr function.
hwnd__ = [T.i32]
          & T.StructureType False
          & Just & A.TypeDefinition (N.Name "struct.HWNDNONP")
hwnd = T.NamedTypeReference (N.Name "struct.HWNDNONP")
       & ptr
hwndPtr = hwnd & ptr
form = [iFormRef, hwnd]
       & T.StructureType False
       & Just & A.TypeDefinition (N.Name "struct.Form")

-- form_vtbl = C.Struct Nothing False [C.GlobalReference iFormLoad (N.Name "Form_Load"), C.GlobalReference iFormShow (N.Name "Form_Show")]
-- -- TODO: can I just say form_vtbl has type iFormVtbl?                  HERE below i mean.   Then wouldn't have to bitcast elsewhere
--             & A.GlobalAlias (N.Name "form_vtbl") L.Internal V.Default (T.StructureType False [iFormLoad, iFormShow])
--             & A.GlobalDefinition

-- FIXME: vtbl members
-- FIXME why does this ICE??
-- form_vtbl = C.Struct Nothing False []
--             & A.GlobalAlias (N.Name "form_vtbl") L.Internal V.Default (T.StructureType False [])
--             & A.GlobalDefinition

form_vtbl =
    A.GlobalDefinition 
            ( A.GlobalVariable 
                (N.Name "form_vtbl")
                L.Internal
                V.Default
                False
                (AddrSpace 0)
                False
                False
                -- iFormVtblRef
                (T.StructureType
                        False
                        [ iFormLoad, iFormShow ]
                )
                (Just
                    -- Crashed when I assigned this to a GlobalAlias.  Hence we wrap in a GlobalVariable.
                    ( C.Struct
                        Nothing
                        False
                        [ C.GlobalReference iFormLoad (N.Name "Form_Load")
                        , C.GlobalReference iFormShow (N.Name "Form_Show")
                        ]
                    )
                )
                Nothing
                4
            )

malloc =
  G.Function L.External V.Default CC.C []
             i8Ptr (N.Name "malloc") ([G.Parameter T.i32 (N.UnName 1) []], False)
             [] Nothing 0 Nothing
             []
  & A.GlobalDefinition
form_load_ref =
  G.Function L.External V.Default x86_stdcallcc []
             T.i32 (N.Name "Form_Load") ([G.Parameter iFormPtr (N.UnName 1) []], False)
             [] Nothing 0 Nothing
             []
  & A.GlobalDefinition
form_show_ref =
  G.Function L.External V.Default x86_stdcallcc []
             T.i32 (N.Name "Form_Show") ([G.Parameter iFormPtr (N.UnName 1) []], False)
             [] Nothing 0 Nothing
             []
  & A.GlobalDefinition
addbtn =
  G.Function L.External V.Default x86_stdcallcc []
             iButtonPtr (N.Name "AddButton") ([G.Parameter iFormPtr (N.UnName 1) []], False)
             [] Nothing 0 Nothing
             []
  & A.GlobalDefinition

i8Ptr = ptr T.i8

iForm = [ptr (T.NamedTypeReference (N.Name "struct.IFormVtbl"))]
        & T.StructureType False
        & Just & A.TypeDefinition (N.Name "struct.IForm")
iFormRef = T.NamedTypeReference (N.Name "struct.IForm")
iFormPtr = iFormRef & ptr
iFormPtrPtr = iFormPtr & ptr
iFormVtblRef = T.NamedTypeReference (N.Name "struct.IFormVtbl")
iFormVtblPtr = iFormVtblRef & ptr
iFormVtblPtrPtr = iFormVtblPtr & ptr
iFormLoad = T.FunctionType T.i32 [iFormPtr] False & ptr
iFormShow = T.FunctionType T.i32 [iFormPtr] False & ptr
iFormVtbl = [ iFormLoad
            , iFormShow
            -- , iFormControlsDotAdd
            ]
            & T.StructureType False
            & Just & A.TypeDefinition (N.Name "struct.IFormVtbl")


iButton = [ptr (T.NamedTypeReference (N.Name "struct.IButtonVtbl"))]
        & T.StructureType False
        & Just & A.TypeDefinition (N.Name "struct.IButton")
iButtonRef = T.NamedTypeReference (N.Name "struct.IButton")
iButtonPtr = iButtonRef & ptr
iButtonPtrPtr = iButtonPtr & ptr
iButtonVtblRef = T.NamedTypeReference (N.Name "struct.IButtonVtbl")
iButtonVtblPtr = iButtonVtblRef & ptr
iButtonVtblPtrPtr = iButtonVtblPtr & ptr
iButtonSetCaption = T.FunctionType T.i32 [iButtonPtr, ptr T.i16] False & ptr
iButtonSetTop = T.FunctionType T.i32 [iButtonPtr, T.FloatingPointType 64 T.IEEE] False & ptr
iButtonSetLeft = T.FunctionType T.i32 [iButtonPtr, T.FloatingPointType 64 T.IEEE] False & ptr
iButtonSetWidth = T.FunctionType T.i32 [iButtonPtr, T.FloatingPointType 64 T.IEEE] False & ptr
iButtonSetHeight = T.FunctionType T.i32 [iButtonPtr, T.FloatingPointType 64 T.IEEE] False & ptr
iButtonVtbl =
  [ iButtonSetCaption
  , iButtonSetTop
  , iButtonSetLeft
  , iButtonSetWidth
  , iButtonSetHeight
  ]
  & T.StructureType False
  & Just & A.TypeDefinition (N.Name "struct.IButtonVtbl")

mkStartup :: () -> (A.Module, RelFile)
mkStartup () =
  let
    varArgs = False
    argDefs = []
    retType = T.VoidType
    -- TODO: replace 4 with typicalAlign?
    blocks =
      [
        G.BasicBlock
          (N.UnName 10)
          -- IForm* form (stack allocate pointer)
          [ N.UnName 1 := I.Alloca iFormPtr Nothing 4 []
          -- = new_form();
          , N.UnName 2 := I.Call False x86_stdcallcc []
                            (C.GlobalReference (T.FunctionType iFormPtr [] False) (N.Name "new_form_codegened") & O.ConstantOperand & Right)
                            []
                            [] []
          , I.Do (I.Store False (O.LocalReference iFormPtrPtr (N.UnName 1)) (O.LocalReference iFormPtr (N.UnName 2)) Nothing 4 [])
          -- form->
          , N.UnName 3 := I.Load False (O.LocalReference iFormPtrPtr (N.UnName 1)) Nothing 4 []
          -- lpVtbl
          , N.UnName 4 := I.GetElementPtr True (O.LocalReference iFormPtr (N.UnName 3)) [C.Int 32 0 & O.ConstantOperand, C.Int 32 0 & O.ConstantOperand] []
          -- ->
          , N.UnName 5 := I.Load False (O.LocalReference iFormVtblPtrPtr (N.UnName 4)) Nothing 4 []
          -- Show (FIXME: don't hard code index 1)
          , N.UnName 6 := I.GetElementPtr True (O.LocalReference iFormVtblPtr (N.UnName 5)) [C.Int 32 0 & O.ConstantOperand, C.Int 32 1 & O.ConstantOperand] []
          , N.UnName 7 := I.Load False (O.LocalReference iFormShow (N.UnName 6)) Nothing 4 []
          -- ready an IForm* to pass as param
          , N.UnName 8 := I.Load False (O.LocalReference iFormPtrPtr (N.UnName 1)) Nothing 4 []
          -- ( call )
          , N.UnName 9 := I.Call False x86_stdcallcc []
                            (O.LocalReference iFormShow (N.UnName 7) & Right)
                            [(O.LocalReference iFormPtr (N.UnName 8), [])]
                            [] []
          ]
          (I.Do (I.Ret Nothing []))
      ]
    newForm =
      G.Function L.External V.Default x86_stdcallcc []
        iFormPtr (N.Name "new_form_codegened") ([], False)
        [] Nothing 0 Nothing
        []
      & A.GlobalDefinition
    -- TODO: call I share code e.g. reuse SProcProtype's semantics?
    startup =
      G.Function L.External V.Default x86_stdcallcc []
        retType (N.Name "proc_main") (argDefs, varArgs)
        [] Nothing 0 Nothing
        blocks
      & A.GlobalDefinition
    -- FIXME defns here versus loc.newForm's global definitions.
    defns = [iForm, iFormVtbl, startup, newForm]
    mod = A.defaultModule { A.moduleDefinitions = defns }
    filename = relFile "form-startup.ll"
  in
    (mod, filename)
}


ATTR SProcs SProc SInProcStmts
     SInProcStmt SExprs [ | | fileLevelDecls USE {<>} {Seq.empty}:
                                {Seq.Seq G.Global} ]

ATTR SProcs       [ | | definition USE {<|} {Seq.empty}: {Seq.Seq A.Definition} ]

ATTR SProc        [ | | definition: {A.Definition} ]
SEM SProc
  | SProcConstr  lhs.definition =
    {
      @proto.definitionDeclaration
      {
        G.basicBlocks =
        [
          G.BasicBlock (N.UnName 0)
                       (toList @body.instr)
                       (I.Do $ I.Ret @retType.defaultVal
                                     [])
        ]
      }
      & A.GlobalDefinition
    }
           inst.retType : SProcRetType
           inst.retType = @proto.retType

ATTR SProcPrototypes [ | | importDeclaration USE {:} {[]}: {[G.Global]} ]
ATTR SProc SInProcStmts SInProcStmt SExprs
     SProcPrototypes SProcPrototype SArgDefs SArgDef SType SExpr SProcRetType
     -- STopLevels STopLevel SAttribute SDim SOption SAttributes
     -- SModule SModules
     SCases SCase
     SNewClassHeaderBlocks SNewClassHeaderBlock SNewProps SNewProp VtableIndex
     [ | | self: SELF ]

ATTR SProcPrototype [ | | importDeclaration: {G.Global}
                          definitionDeclaration: {G.Global}
                          asCallable: {O.CallableOperand}
                          retType: SProcRetType ]
SEM SProcPrototype
  | SProcPrototype
      -- The declaration is necessary in a file calling this procedure,
      -- if the file calling this function is different from the one
      -- containing its implementation.
      lhs.importDeclaration = @loc.proto
      -- Used when the implementation of our procedure is defined.
      lhs.definitionDeclaration = @loc.proto
      lhs.asCallable = Right . O.ConstantOperand .
                         (C.GlobalReference @loc.ty) $
                         procName @self
      loc.ty = T.FunctionType @retType.ty @loc.argTys @loc.varArgs
      loc.argTys = map (\(G.Parameter t _ _) -> t) (toList @argDefs.defn)
      loc.retType = @retType.self
      loc.linkage = L.External
      loc.varArgs = False
      loc.proto = G.Function @loc.linkage V.Default x86_stdcallcc []
                    @retType.ty (procName @self)
                    (toList @argDefs.defn, @loc.varArgs)
                    [] Nothing 0 Nothing []

{
procName :: SProcPrototype -> N.Name
procName SProcPrototype {implProject_SProcPrototype_SProcPrototype =
                           implProject,
                         name_SProcPrototype_SProcPrototype = name}
         | implProject == vbaProjectName = N.Name (raw name)
         | otherwise = N.Name ("proc_" ++ normalized name)

-- | The name of the standard library Project (\"VBA\") as a `SymbolName'.
vbaProjectName :: SymbolName
vbaProjectName = mkSymbolName "VBA"
}

ATTR SArgDefs [ | | defn USE {<|} {Seq.empty}: {Seq.Seq G.Parameter} ]

ATTR SArgDef  [ | | defn: {G.Parameter} ]
SEM SArgDef
  | SArgDef  lhs.defn = G.Parameter @ty.ty (N.UnName 0) []

ATTR SType [ | | defaultVal: {O.Operand}
                 defaultValish: {C.Constant}
                 ty: {T.Type} ]

SEM SType
  | SBoolean  loc.ty = error "Ir SType | SBoolean: ty"
              loc.defaultValish = error "Ir SType | SBoolean: defaultValish"
              lhs.defaultVal = O.ConstantOperand @loc.defaultValish
  | SDouble  loc.ty = T.FloatingPointType 64 T.IEEE
             loc.defaultValish = C.Float (Float.Double 0.0)
             lhs.defaultVal = O.ConstantOperand @loc.defaultValish
  | SInteger  loc.ty = error "Ir SType | SInteger: ty"
              loc.defaultValish = error "Ir SType | SInteger: defaultValish"
              lhs.defaultVal = O.ConstantOperand @loc.defaultValish
  | SString  loc.ty = (T.PointerType (T.IntegerType 16) (AddrSpace 0))
             loc.defaultValish = C.Null @loc.ty
             lhs.defaultVal = O.ConstantOperand @loc.defaultValish
  | SVariant  loc.ty = error "Ir SType | SVariant: ty"
              loc.defaultValish = error "Ir SType | SVariant: defaultValish"
              lhs.defaultVal = O.ConstantOperand @loc.defaultValish



ATTR SProcRetType [ | | defaultVal: {Maybe O.Operand}
                        ty: {T.Type} ]
SEM SProcRetType
  | Just     lhs.ty = @just.ty
             lhs.defaultVal = Just @just.defaultVal
  | Nothing  lhs.ty = T.VoidType
             lhs.defaultVal = Nothing

ATTR SInProcStmts [ | | instr USE {<>} {Seq.empty}:
                          {Seq.Seq (I.Named I.Instruction)} ]

ATTR SInProcStmt  [ | | instr: {Seq.Seq (I.Named I.Instruction)} ]
SEM SInProcStmt
  | SIf  lhs.instr = error "Ir: SIf"
  | SCall  lhs.instr = I.Do (I.Call False x86_stdcallcc [] @proc.asCallable
                                    (toList @args.operandEtc) [] [])
                       & Seq.singleton
  -- FIXME alignment
  | SLet  lhs.instr =
            @expr.loadInstrs
            |> (I.Do (I.Store False @loc.dest @loc.src Nothing 8 []))
          loc.name = raw @var & map Char.toLower & N.Name
          -- FIXME: lookup @var in symbol table to get dest storage ref & type
          -- FIXME: if the variable was dimmed locally as opposed to module level then will be
          --  O.LocalReference instead of O.ConstantOperand)
          loc.dest = C.GlobalReference (T.FloatingPointType 64 T.IEEE) @loc.name & O.ConstantOperand
          loc.src = @expr.operand

ATTR SExprs [ | | operandEtc USE {<|} {Seq.empty}:
                    {Seq.Seq (O.Operand, [ParameterAttribute])} ]

ATTR SExpr [ | | fileLevelDecls: {Seq.Seq G.Global}
                 -- FIXME: use this loadInstrs where required (everywhere operand or operandEtc is used)
                 loadInstrs: {Seq.Seq (I.Named I.Instruction)}
                 operand: {O.Operand}
                 operandEtc: {(O.Operand, [ParameterAttribute])} ]
SEM SExpr
  | SAdd
      lhs.fileLevelDecls = @x.fileLevelDecls <> @y.fileLevelDecls
      loc.uniqueN : UNIQUEREF counter
      loc.name = N.UnName (fromIntegral @loc.uniqueN)
      lhs.loadInstrs =
        @x.loadInstrs <> @y.loadInstrs
        -- FIXME FAdd is only for floating point
        |> (@loc.name := I.FAdd (I.NoFastMathFlags) (@x.operand) (@y.operand) [])
      loc.operand = O.LocalReference @ty.ty @loc.name
      lhs.operandEtc = (@loc.operand, [])
  | SIdentExpr
    lhs.fileLevelDecls = Seq.empty
    loc.uniqueN : UNIQUEREF counter
    loc.namenum = N.UnName (fromIntegral @loc.uniqueN)
    -- FIXME: if the variable was dimmed locally as opposed to module level then will be
    --  O.LocalReference instead of O.ConstantOperand)
    -- FIXME: alignment
    loc.loadInstrs = @loc.namenum := I.Load False (C.GlobalReference @ty.ty @loc.myname & O.ConstantOperand) Nothing 8 [] & Seq.singleton
    loc.operand = O.LocalReference @ty.ty @loc.namenum
    -- this approach failed (need the load):
    -- loc.operand2 = C.GlobalReference @ty.ty @loc.myname & O.ConstantOperand
    -- loc.operand = O.ConstantOperand (C.Float (Float.Double 777.0))
    loc.myname = raw @name & map Char.toLower & N.Name
    lhs.operandEtc = (@loc.operand, [])
  | SDoubleLit
    lhs.fileLevelDecls = Seq.empty
    loc.loadInstrs = Seq.empty
    loc.operand = O.ConstantOperand (C.Float (Float.Double @val))
    lhs.operandEtc = (@loc.operand, [])
  | SIntegerLit
    lhs.fileLevelDecls = Seq.empty
    loc.loadInstrs = Seq.empty
    loc.operand = O.ConstantOperand (C.Int 32 @val)
    lhs.operandEtc = (@loc.operand, [])
  | SStringLit  -- Determine a unique register to store the string
                -- contents into.
                loc.uniqueN : UNIQUEREF counter
                loc.register = N.Name $ "s" ++ show @loc.uniqueN
                -- Store the string contents (outwith the procedure).
                -- Requires determining the type.  We null terminate the
                -- string.
                loc.fileLevelDecls =
    {
      Seq.singleton $
      G.GlobalVariable @loc.register L.Private V.Default False (AddrSpace 0)
                       False True @loc.contentsType
                       (Just $ word16sToIr @loc.word16s)
                       Nothing 0
    }
                loc.word16s = hsStringToWord16s @val
                loc.contentsType =
                     T.ArrayType (fromIntegral $ length @loc.word16s)
                                 (T.IntegerType 16)
                loc.loadInstrs = Seq.empty
                -- Whenever any generated code needs the string, we
                -- refer to it via a (typed) pointer.
                loc.operand =
    {
      O.ConstantOperand $ C.GetElementPtr
                            True
                            (C.GlobalReference @loc.contentsType @register)
                            [C.Int 64 0, C.Int 64 0]
    }
                lhs.operandEtc = (@loc.operand, [])

-- Support functions for translating string literals
{
-- | Translate a list of UTF-16 codepoints (with host endianness)
-- representing the body of a string literal, to the `Ir' form of the
-- list (which is endian neutral).  Does not add a trailing NUL.
word16sToIr :: [Word16] -> C.Constant
word16sToIr xs = C.Array (T.IntegerType 16)
                         (map (\x -> C.Int 16 (fromIntegral x)) xs)

-- | Convert a standard Haskell string to a list of UTF-16 codepoints
-- (with host endianness).  Adds a trailing NUL.
hsStringToWord16s :: String -> [Word16]
hsStringToWord16s xs = xs
                       & T.pack & encodeUtf16BE & B.unpack & takePairs
                       <&> uncurry word8sToWord16
                       & (++ [0])

-- | Convert a list into a list of pairs, by taking two consecutive
-- elements at a time.
takePairs :: [a] -> [(a, a)]
takePairs [] = []
takePairs [_] = []
takePairs (x:y:z) = [(x, y)] ++ takePairs z

-- | Return a 16-bit unsigned number, which was inputted as two octects
-- in big endian order.
word8sToWord16 :: Word8 -> Word8 -> Word16
word8sToWord16 a b = a' * 256 + b'
    where a' = fromIntegral a :: Word16
          b' = fromIntegral b :: Word16
}


-- * Here we have to keep track of symbols, for use in the main IR
-- generation code.

-- Keep track of the Project and the Module we are generating code for.
-- users.  Note that for symbols such as procedures there is a
-- distinction between the module (or project) we are generating code
-- for, and the module (or project) containing the implementation;
-- cf. the `isModuleLocal' attribute.
ATTR SModules SModule [ inProject: SymbolName | | ]
-- FIXME long line
ATTR STopLevels STopLevel
     SProcs SProc
     SElseIfs SElseIf
     SProcPrototypes SProcPrototype SInProcStmts SInProcStmt
     SCases SCase
                      [ inProject: SymbolName
                        inModule: SymbolName  | | ]
SEM SProject
  | SProject  modules.inProject = @name

SEM SModule
  | SBasModule  topLevel.inModule = @name
  | SForm  topLevel.inModule = @name

-- SEM STopLevels
--   | Cons  hd.inModule = @loc.inModule
--   | Nil

-- SEM STopLevel
--   | SAttribute
--   | SDim
--   | SOption
--   | SProc  proc.inModule = error "FIXME"

-- Keep track of calls to procedures implemented in files other than the
-- file containing the call; the prototypes of these functions need
-- declared in the files calling them.
ATTR SProcs SProc SInProcStmts SExpr [ | | usedNonLocalProcs:
                                       {Set.Set SProcPrototype} ]
ATTR SInProcStmt [ | | usedNonLocalProcs: {Set.Set SProcPrototype} ]

SEM SProcs
  | Cons  lhs.usedNonLocalProcs = @tl.usedNonLocalProcs `Set.union`
                                  @hd.usedNonLocalProcs
  | Nil   lhs.usedNonLocalProcs = Set.empty

SEM SInProcStmts
  | Cons  lhs.usedNonLocalProcs = @hd.usedNonLocalProcs `Set.union`
                                  @tl.usedNonLocalProcs
  | Nil   lhs.usedNonLocalProcs = Set.empty

SEM SInProcStmt
  | SCall  lhs.usedNonLocalProcs = if @proc.isModuleLocal
                                   then Set.empty
                                   else Set.singleton @proc.self
  | SLet  lhs.usedNonLocalProcs = Set.empty
  | SIf
      inst.elseIfs2 : SElseIfs
      inst.elseIfs2 = @elseIfs & map (uncurry SElseIf)
      lhs.usedNonLocalProcs =
        [@cond.usedNonLocalProcs, @true.usedNonLocalProcs, @elseIfs2.usedNonLocalProcs,@false.usedNonLocalProcs]
        & Set.unions

{
  -- or i could tell uuagc to generate data for this module.  but not export.
data SElseIf =
  SElseIf { cond_SElseIf_SElseIf :: SExpr, stmts_SElseIf_SElseIf :: SInProcStmts}
type SElseIfs = [SElseIf]
}
DATA SElseIf
   | SElseIf  cond: SExpr  stmts: SInProcStmts
TYPE SElseIfs = [SElseIf]
ATTR SElseIfs [ | | usedNonLocalProcs USE {`Set.union`} {Set.empty}: {Set.Set SProcPrototype} ]
ATTR SElseIf  [ | | usedNonLocalProcs: {Set.Set SProcPrototype} ]
SEM SElseIf
  | SElseIf
    lhs.usedNonLocalProcs = Set.union @cond.usedNonLocalProcs @stmts.usedNonLocalProcs

SEM SExpr
  | SDoubleLit  lhs.usedNonLocalProcs = Set.empty
  | SStringLit  lhs.usedNonLocalProcs = Set.empty
  | SIntegerLit  lhs.usedNonLocalProcs = Set.empty
  | SIdentExpr  lhs.usedNonLocalProcs = Set.empty
  | SAdd  lhs.usedNonLocalProcs = Set.union @x.usedNonLocalProcs @y.usedNonLocalProcs
  -- A call expression could be non-empty

-- This answers this question: Is the procedure which is being used
-- (that is, being called) being used in the module (and project)
-- containing the procedure's implementation?
ATTR SProcPrototype [ | | isModuleLocal: Bool ]
SEM SProcPrototype
  | SProcPrototype  lhs.isModuleLocal = @lhs.inProject == @implProject &&
                                        @lhs.inModule == @implModule
