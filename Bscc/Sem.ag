-- -*- auto-fill-mode: nil; indent-tabs-mode: nil; -*-

optpragmas
{
-- Copyright Â© 2012 Iain Nicol

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Semantic analysis.

-- This comment separates above doc comment and UUAGC-inserted comment
}

MODULE {Bscc.Sem}
-- Exports
{
semAnalysis
}
-- Imports
{
import Bscc.Ast.Plain
import Bscc.Ast.WithSem
import Bscc.Sem.Internal.Types
import Bscc.Symbol.Name (mkSymbolName, SymbolName)
import Bscc.Symbol.Table as SymTable

import Control.Lens.Operators ((&), (<&>))
import Data.Foldable (toList)
import Data.Maybe (maybeToList)
import Data.Monoid ((<>), mempty)
import qualified Data.Sequence as Seq
import Prelude hiding (FilePath)
import System.Path (RelFile, takeBaseName)
import qualified System.Path as Path
}

INCLUDE "Ast/Plain.ag"
INCLUDE "Ast/WithSem.ag"
INCLUDE "Sem/Internal/Types.ag"


{
-- | Perform semantic analysis.  Resolve identifiers, etc.
semAnalysis :: Project -> Either (Seq.Seq SemError) SProject
semAnalysis t =
  let inh = Inh_Project { errs_Inh_Project = mempty }
      sems = wrap_Project (sem_Project t) inh
      errs = errs_Syn_Project sems
      annotatedAst = typedAst_Syn_Project sems
  in if Seq.null errs
     then Right annotatedAst
     else Left errs
}

-- * Error handling.

{
data SemError
  = SymbolNotFound SymbolName
  | DuplicateSymbol { symbol :: SymbolName, module_ :: SymbolName }
  | SubMainDoesNotExist
  -- Not subsumed by DuplicateSymbol, because that deals with duplicates
  --  within a single module:
  | SubMainTooMany
  | CallArgumentWrongType  { expr :: Expr, expectedType :: SType }
  | CallArgumentsWrongLength { callee :: SymbolName }
  deriving (Eq, Show)
}

ATTR Project Modules Module TopLevels TopLevel
     Procs Proc InProcStmts InProcStmt ElseIfs ElseIf
     Cases Case
  [ | errs : {Seq.Seq SemError} | ]
-- FIXME: why is errs in the middle but symbolTable on the left (inh)?
-- TODO: can we use "+" with symbolTable / exportedSymbols
-- FIXME: is the large text comment aboutthe symbol table magic
-- slightly misleading ("exported" vs private)

-- * This section is the boring and straightforward part of the
-- transformation.

ATTR Exprs Expr
     CallType
     Proc ArgDefs ArgDef Type InProcStmts InProcStmt
     SProcPrototype SArgDefs SArgDef SType SProcRetType SExpr
     ClassHeaderBlock ClassHeaderBlockParts ClassHeaderBlockPart
     Cases Case
     [ | | self: SELF ]

ATTR Project [ | | typedAst: SProject ]
SEM Project
  | Project  lhs.typedAst = SProject @modules.typedAst @name

-- FIXME move into right place?
ATTR TopLevels [ | | typedAst USE {:} {[]}: STopLevels ]
ATTR TopLevel [ | | typedAst: STopLevel ]
SEM TopLevel
  | Attribute  lhs.typedAst = SAttribute @attr.typedAst
  | Dim  lhs.typedAst = SDim @dim.typedAst
  | Option  lhs.typedAst = SOption @option.typedAst
  | Proc  lhs.typedAst = SProc @proc.typedAst

ATTR TopLevels   [ | | procs USE {<>} {Seq.empty}:
                          {Seq.Seq Proc} ]
ATTR TopLevel    [ | | procs: {Seq.Seq Proc} ]
SEM TopLevel
   | Attribute  lhs.procs = Seq.empty
   | Dim  lhs.procs = Seq.empty
   | Option  lhs.procs = Seq.empty
   | Proc  lhs.procs = Seq.singleton @proc.self

ATTR Modules [ | | typedAst USE {:} {[]}: SModules ]
ATTR Module  [ | | typedAst: SModule ]

SEM Module
  | BasModule  inst.procs : Procs
               inst.procs = toList @topLevels.procs
               procs.inProject = @lhs.inProject
               procs.inModule = @name
               lhs.typedAst = SBasModule @path @topLevels.typedAst @loc.name
               loc.name' = Path.toString $ takeBaseName @path
               loc.name = mkSymbolName (if null @loc.name'
                                        then "Module1"
                                        else @loc.name')
  | Form       inst.procs : Procs
               inst.procs = toList @topLevels.procs
               procs.inProject = @lhs.inProject
               procs.inModule = @name
               lhs.typedAst = SForm @path
                                    @header.typedAst
                                    @topLevels.typedAst
                                    @loc.name -- FIXME long
               loc.name' = Path.toString $ takeBaseName @path
               loc.name = mkSymbolName (if null @loc.name'
                                        then "Form1"
                                        else @loc.name')

ATTR Attribute  [ | | typedAst: SAttribute ]
SEM Attribute
  | AttributeConstr  lhs.typedAst = SAttributeConstr

ATTR Dim   [ | | typedAst: SDim ]
SEM Dim
  | DimConstr  lhs.typedAst = SDimConstr @name @ty.typedAst

ATTR MaybeType  [ | | typedAst: SType ]
SEM MaybeType
  | Just  lhs.typedAst = @just.typedAst
  | Nothing  lhs.typedAst = SVariant

ATTR Option   [ | | typedAst: SOption ]
SEM Option
  | OptionConstr  lhs.typedAst = SOptionConstr

-- ATTR Procs [ | | typedAst USE {:} {[]}: SProcs ]
ATTR Proc  [ | | typedAst: SProc  proto: SProcPrototype ]

SEM Proc
  | Sub  lhs.typedAst = SProcConstr @loc.proto @body.typedAst
         loc.proto = SProcPrototype @name
                                    @argDefs.typedAst  Nothing
                                    @lhs.inProject @lhs.inModule

ATTR ClassHeaderBlock [ | | typedAst: SClassHeaderBlock ]
SEM ClassHeaderBlock
  | ClassHeaderBlock  lhs.typedAst = SClassHeaderBlock  @classname @main.typedAst

ATTR ClassHeaderBlockParts [ | | typedAst USE {:} {[]}: SClassHeaderBlockParts ]
ATTR ClassHeaderBlockPart [ | | typedAst: SClassHeaderBlockPart ]
SEM ClassHeaderBlockPart
  | ClassHeaderChild  lhs.typedAst = SClassHeaderChild @child.typedAst
  | ClassHeaderProp  lhs.typedAst = SClassHeaderProp @name  @val.translated
                     val.symbolTable = mempty
  | ClassHeaderPropBlock  lhs.typedAst = SClassHeaderPropBlock

ATTR ArgDefs [ | | typedAst USE {:} {[]}: SArgDefs ]
ATTR ArgDef  [ | | typedAst: SArgDef ]
SEM ArgDef
  | ArgDef  lhs.typedAst = SArgDef @name @ty.typedAst

ATTR Type [ | | typedAst: SType ]
SEM Type
  | Boolean  lhs.typedAst = error "Sem: Type: Boolean" -- TODO
  | Double  lhs.typedAst = SDouble
  | Integer  lhs.typedAst = SInteger
  | String  lhs.typedAst = SString
  | Variant  lhs.typedAst = SVariant

ATTR InProcStmts [ | | typedAst USE {:} {[]}: SInProcStmts ]
ATTR InProcStmt  [ | | typedAst: SInProcStmt ]
SEM InProcStmt
  -- FIXME SymTable.lookup: make sure we found a proc, not a variable
  | Call  loc.maybeFoundCallee = SymTable.lookup @fn
                                                 @lhs.symbolTable
                                 & fmap snd -- FIXME vtblIdx
          loc.errsNotFound = case @loc.maybeFoundCallee of
                               Just s -> mempty
                               Nothing -> Seq.singleton $ SymbolNotFound @fn
          loc.maybeFoundCalleeProto =
            @loc.maybeFoundCallee <&> SymTable.proto_Symbol_SymbolProc
          inst.foundCalleeProto : SProcPrototype
          inst.foundCalleeProto =
            case @loc.maybeFoundCalleeProto of
              Just s -> s
              Nothing -> error "SEM InProcStmt | Call: foundCalleeProto"
          inst.foundCalleeArgDefs : SArgDefs
          inst.foundCalleeArgDefs = toList @foundCalleeProto.argDefs
          inst.coercedArgs : CoercedExprs
          inst.coercedArgs = zip (toList @args.self) (@foundCalleeArgDefs.ty)
          -- FIXME is this required? or copy ruled?
          -- coercedArgs.symbolTable = @lhs.symbolTable
          loc.errsBadArgs =
            if not $ Seq.null @loc.errsNotFound
            -- Can't determine if the arguments are invalid if we can't
            -- find the function being called.
            then mempty
            else if length @args.self /= length @foundCalleeProto.argDefs
                 then Seq.singleton $ CallArgumentsWrongLength @fn
                 else @coercedArgs.coercionErrs
          +errs = (<> @loc.errsNotFound <> @loc.errsBadArgs)
          loc.args = if Seq.null @loc.errsBadArgs
                     then @coercedArgs.typedAst
                     else error "SEM InProcStmt | Call: loc.args"
          lhs.typedAst = SCall @foundCalleeProto.self @loc.args
  | SelectCase
      inst.default2 : InProcStmts
      inst.default2 = @default' & maybeToList & concat
      lhs.typedAst = SSelectCase @expr.translated  @cases.typedAst @default2.typedAst
  | If
      loc.true = @true.typedAst
      inst.false2 : InProcStmts
      inst.false2 = @false & maybeToList & concat
      inst.elseIfs2 : ElseIfs
      inst.elseIfs2 = @elseIfs & map (uncurry ElseIf)
      lhs.typedAst = SIf @cond.translated @loc.true @elseIfs2.typedAst @false2.typedAst
  | Let  lhs.typedAst = SLet @var @expr.translated

ATTR Cases [ | | typedAst USE {:} {[]}: SCases ]
ATTR Case  [ | | typedAst: SCase ]
SEM Case
  | Simple  lhs.typedAst = SSimple  @expr.translated  @stmts.typedAst

{
  -- or i could tell uuagc to generate data for this module.  but not export.
data ElseIf =
  ElseIf { cond_ElseIf_ElseIf :: Expr, stmts_ElseIf_ElseIf :: InProcStmts}
type ElseIfs = [ElseIf]
}
DATA ElseIf
   | ElseIf  cond: Expr  stmts: InProcStmts
TYPE ElseIfs = [ElseIf]
ATTR ElseIfs [ | | typedAst USE {:} {[]}: {[(SExpr, SInProcStmts)]} ]
ATTR ElseIf  [ | | typedAst: {(SExpr, SInProcStmts)} ]
SEM ElseIf
  | ElseIf
    lhs.typedAst = (@cond.translated, @stmts.typedAst)

ATTR SProcPrototype [ | | argDefs: SArgDefs ]
SEM SProcPrototype
  | SProcPrototype  lhs.argDefs = @argDefs.self

ATTR SArgDefs [ | | ty USE {:} {[]}: {[SType]} ]
ATTR SArgDef [ | | ty: SType ]
SEM SArgDef
  | SArgDef  lhs.ty = @ty.self


-- * Here beings the magic: the construction of the symbol table, and
-- other symbol-information jazz.

-- How does the symbol table magic work?  Every Module pushes up
-- (synthesized attribute: `exportedSymbols') a collection of symbols it
-- exports, by which we mean are visible outside of its own file.  These
-- symbol collections are only useful for one thing.  At the project
-- level, these are combined with external symbols such as ones from the
-- standard library.  This defines a Project level symbol table, which
-- is then pushed down (inherited attribute).  A symbol table (attribute
-- name: `symbolTable') is then built for each scope, with symbols
-- defined within each file, whether exported or not, taking precedence
-- over the globally-inherited symbols.
--
-- We keep track of which Project (inProject) or Module (inModule) being
-- analyzed.  For both semantic analysis and codegen we need to know
-- where symbols (and their implementation or storage, etc.) reside.

-- FIXME: understaand why this symbolTable is lhs but the other symboltables are understandably inh.
ATTR Project        [ | | symbolTable: {SymbolTable} ]
ATTR Modules Module TopLevels TopLevel Procs Proc [ inProject: SymbolName | | ]
SEM Project
  | Project   -- Add in symbols from the standard library (libvbstd)
              -- those exported from the source files of the project.
             loc.symbolTable = @modules.exportedSymbols
                               `SymTable.union` libvbstdProtos
             modules.symbolTable = @loc.symbolTable
             modules.inProject = @name

{
-- | Symbols exported from the standard library (libvbstd).
libvbstdProtos :: SymbolTable
libvbstdProtos = toSymbolTable $ map (\x -> (Nothing, SymbolProc x)) procs
  where procs = [SProcPrototype (mkSymbolName "MsgBox")
                                [SArgDef (mkSymbolName "Prompt") SString]
                                Nothing (mkSymbolName "VBA")
                                (mkSymbolName "Interaction")]

-- buttonVtbl :: SymbolTable
-- buttonVtbl =
--   [ SetCaption IButton* -> BSTR -> HRESULT
--   , SetWidth  IButton* -> float -> HRESULT
--   , SetHeight  IButton* -> BSTR -> HRESULT
--   ,
--   ]

-- formVtbl :: SymbolTable
-- formVtbl
--   [ Load  IForm* -> HRESULT
--   , Show  IForm* -> HRESULT
--   , ControlsDotAdd  IForm* -> BSTR -> BSTR -> VARIANT -> IButton*
--   ,
--   ]
}

ATTR Modules Module TopLevels TopLevel Procs Proc
     Cases Case
     InProcStmts InProcStmt CallType ElseIfs ElseIf Exprs Expr CoercedExprs CoercedExpr [ symbolTable: {SymbolTable} | | ]
-- Implicit SEM: the symbolTable is inherited all the way down.

ATTR Modules [ | | exportedSymbols
                   USE {`SymTable.union`} {SymTable.empty}: {SymbolTable} ]
ATTR Module TopLevels [ | | exportedSymbols: {SymbolTable} ]
SEM TopLevels
  | Cons  -- loc.errsProc =
          -- {
          --   case SymTable.lookup @hd.name @tl.exportedSymbols of
          --     Just _ -> Seq.singleton $ DuplicateSymbol @hd.name @lhs.inModule
          --     Nothing -> mempty
          -- }
          --  +errs = (<> @loc.errsProc)
          lhs.exportedSymbols = case @hd.exportedSymbol of
                                  Just (vtblIdx, exportedSymbol) -> SymTable.insert vtblIdx exportedSymbol @tl.exportedSymbols
                                  Nothing -> @tl.exportedSymbols
  | Nil   lhs.exportedSymbols = SymTable.empty

ATTR TopLevel Dim [ | | exportedSymbol: {Maybe (Maybe VtableIndex, Symbol)} ]
SEM TopLevel
  | Attribute  lhs.exportedSymbol = Nothing
  | Option  lhs.exportedSymbol = Nothing
  | Proc
    loc.vtblIdx = Nothing -- FIXME
    lhs.exportedSymbol = Just (@loc.vtblIdx, SymbolProc @proc.proto)
  -- | Dim  lhs.exportedSymbol = @dim.exportedSymbol

SEM Dim
  | DimConstr
    loc.vtblIdx = Nothing -- FIXME
    lhs.exportedSymbol = Just (@loc.vtblIdx, SymbolVariable @name @ty.typedAst)

ATTR Proc [ | | name: SymbolName ]
SEM Proc
  -- TODO: Visibility
  | Sub  lhs.name = @name

ATTR TopLevels TopLevel Procs Proc [ inModule: SymbolName | | ]
SEM Module
  | BasModule  topLevels.inModule = @loc.name
  | Form       topLevels.inModule = @loc.name


-- * Handling Sub Main, the entry point to the program.
SEM Project
  | Project
             -- loc.mainErrs = case Seq.length @modules.mainProcs of
             --                  0 -> Seq.singleton SubMainDoesNotExist
             --                  1 -> mempty
             --                  _ -> Seq.singleton SubMainTooMany
             loc.mainErrs = Seq.empty
             +errs = (@loc.mainErrs <>)

ATTR Modules [ | | mainProcs USE {<>} {Seq.empty}: {Seq.Seq SProcPrototype}]
ATTR Module [ | | mainProcs: {Seq.Seq SProcPrototype} ]
SEM Module
   | BasModule  lhs.mainProcs = case SymTable.lookup (mkSymbolName "Main")
                                                     @topLevels.exportedSymbols of
                                  Just (_vtblIdx, SymbolProc proto) ->
                                    Seq.singleton proto
                                  _ -> mempty
   | Form       lhs.mainProcs = mempty


-- * Support for expressions and their coercion.

ATTR Expr [ | | translated: SExpr ]
SEM Expr
  | Add
    inst.xt : SExpr
    inst.xt = @x.translated
    -- FIXME: type of Add
    lhs.translated = SAdd @xt.self @y.translated @xt.ty
  | BooleanLit  lhs.translated = error "Sem: Expr: BooleanLit" -- TODO
  | CallExpr  lhs.translated = error "Sem: Expr: CallExpr" -- TODO
  | DoubleLit  lhs.translated = SDoubleLit @val SDouble
  | IntegerLit  lhs.translated = SIntegerLit @val SInteger
  | StringLit  lhs.translated = SStringLit @val SString
  -- FIXME error handling
  | IdentExpr lhs.translated = case SymTable.lookup @name @lhs.symbolTable of
                                 Just (_vtblIdx, SymbolVariable name ty) ->
                                   SIdentExpr name ty
                                 _ -> error ("IdentExpr: no variable symbol found\n" ++ "name: " ++ show @name ++ "\n" ++ show @lhs.symbolTable)

ATTR CoercedExprs [ | | coercionErrs USE {<>} {Seq.empty}: {Seq.Seq SemError} ]
ATTR CoercedExprs [ | | typedAst USE {:} {[]}: SExprs ]
ATTR CoercedExpr [ | | coercionErrs: {Seq.Seq SemError}
                       typedAst: SExpr ]
SEM CoercedExpr
  | Tuple  inst.expr : Expr
           inst.expr = @x1.self
           inst.expr' : SExpr
           inst.expr' = @expr.translated
           loc.targetType = @x2.self
           loc.coercionErrs =
             if @expr'.ty == @loc.targetType
             then mempty
             else Seq.singleton $
                  CallArgumentWrongType @expr.self @loc.targetType
           lhs.typedAst =
             if Seq.null @loc.coercionErrs
             then @expr'.self
             else error "SEM CoercedExpr | Tuple: lhs.typedAst"

ATTR SExpr [ | | ty: SType ]
SEM SExpr
  | SDoubleLit  lhs.ty = @ty.self
  | SStringLit  lhs.ty = @ty.self
  | SIntegerLit  lhs.ty = @ty.self
  | SIdentExpr  lhs.ty = @ty.self
