-- -*- auto-fill-mode: nil; indent-tabs-mode: nil; -*-

optpragmas
{
-- Copyright Â© 2012 Iain Nicol

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.


-- (Just below is the module-level documentation.  However, we cannot
-- make it a Haddock comment because that would cause compile failures
-- when we are INCLUDEd from another .ag file with its own doc comment.)

-- A plain Abstract syntax tree, such as a parse result.
-- cf. "Bscc.Ast.WithSem".
--
-- Most of the AST datatypes should hopefully be self explanatory.
}

MODULE {Bscc.Ast.Plain}
-- Exports
{

Project (..),                  -- $Project
Visibility (..),
Modules, Module (..),          -- $Module
ClassHeaderBlocks,
ClassHeaderBlock (..), ClassHeaderBlockParts, ClassHeaderBlockPart (..), -- FIXME is this the right order relative to impl and also other import lines?
TopLevels, TopLevel (..), Attribute (..), Dim (..), Option (..),
Cases, Case (..),
Procs, Proc (..),              -- $Proc
ArgDefs, ArgDef (..),          -- $ArgDef
Type (..),  MaybeType,         -- $Type
CallType (..),
InProcStmts, InProcStmt (..),  -- $InProcStmt
Exprs, Expr (..)               -- $Expr
}
-- Imports
{
import Bscc.Symbol.Name

import Prelude hiding (FilePath)
import System.Path (RelFile)
}


DERIVING *: Eq
DERIVING *: Show

{
-- $Project
-- A project is a collection of source files which compile into a single
-- executable.  For each program to be compiled, this is the type of
-- the root node.
}
DATA Project
   | Project  modules: Modules  name: SymbolName

DATA Visibility
   | Private
   | Public

TYPE Modules = [Module]

{
-- $Module
-- A module, or a (parsed) source file.
--
-- `BasModule': a \".bas\" file module.
}
DATA Module
   | BasModule  path: RelFile  topLevels: TopLevels
   | Form  path: RelFile  header: ClassHeaderBlock topLevels: TopLevels
-- FIXME singular or plural topLevel?  also in WithSem.ag

-- FIXME: we don't use this here.  we flatten when we convert to sem.
TYPE ClassHeaderBlocks = [ClassHeaderBlock]

DATA ClassHeaderBlock
   | ClassHeaderBlock  classname: String  name: SymbolName  main: ClassHeaderBlockParts
TYPE ClassHeaderBlockParts = [ClassHeaderBlockPart]
DATA ClassHeaderBlockPart
   | ClassHeaderChild  child: ClassHeaderBlock
   | ClassHeaderProp  name: SymbolName   val: Expr
   | ClassHeaderPropBlock

TYPE TopLevels = [TopLevel]

DATA TopLevel
   | Attribute  attr: Attribute
   | Dim  dim: Dim
   | Option  option: Option
   | Proc  proc: Proc

DATA Attribute
   | AttributeConstr

TYPE MaybeType = MAYBE Type

DATA Dim
   | DimConstr  name: SymbolName  ty: MaybeType

DATA Option
   | OptionConstr

TYPE Procs = [Proc]

{
-- $Proc
-- A procedure.
--
-- `Sub': A Sub has no return type.
}
DATA Proc
   | Sub  vis: (Maybe Visibility)  name: SymbolName  argDefs: ArgDefs
          body: InProcStmts

TYPE ArgDefs = [ArgDef]

{
-- $ArgDef
-- Defines an argument accepted by a `Proc'.
}
DATA ArgDef
   | ArgDef  name: SymbolName  ty: Type

{
-- $Type
-- Represents a data type.  Remember, the type represented is a VB type,
-- not a Haskell type.
}
DATA Type
   | Boolean
   | Double
   | Integer
   | String
   | Variant

TYPE InProcStmts = [InProcStmt]

DATA CallType
   | CallType fn: SymbolName  args: Exprs

{
-- $InProcStmt
-- A statement inside a `Proc'.

-- `Call': a Call statement
-- `Let': a Let assignment
}
DATA InProcStmt
   -- TODO: use Call type.  To share with Expr.
   | Call  fn: SymbolName  args: Exprs
   | SelectCase  expr: Expr  cases: Cases  default': {Maybe InProcStmts}
   | If cond: Expr  true: InProcStmts  elseIfs: {[(Expr, InProcStmts)]}  false: {Maybe InProcStmts}
   | Let  var: SymbolName  expr: Expr

TYPE Cases = [Case]
DATA Case
   | Simple  expr: Expr stmts: InProcStmts

TYPE Exprs = [Expr]

{
-- $Expr
-- An expression.
}
-- FIXME: SExpr
DATA Expr
   | BooleanLit  val: Bool
   | CallExpr  call: CallType
   | DoubleLit  val: Double
   | IdentExpr  name: SymbolName
   | IntegerLit  val: Integer -- FIXME int16?
   | StringLit  val: String
   | Add  x: Expr  y: Expr
