-- -*- auto-fill-mode: nil; indent-tabs-mode: nil; -*-

optpragmas
{
-- Copyright Â© 2012 Iain Nicol

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.


-- (Just below is the module-level documentation.  However, we cannot
-- make it a Haddock comment because that would cause compile failures
-- when we are INCLUDEd from another .ag file with its own doc comment.)

-- Abstract syntax tree with information from semantic analysis
-- ("Bscc.Sem"), such as type information.
--
-- Most data types and constructors here correspond to those in
-- "Bscc.Ast.Plain", except that this module prefixes such with \"S\"
-- for \"Semantics\".
}

MODULE {Bscc.Ast.WithSem}
-- Exports
{
SProject (..),
SModules, SModule (..),
VtableIndex (..),
SNewClassHeader (..), SNewClassHeaderBlocks, SNewClassHeaderBlock (..), SNewProps, SNewProp (..),
STopLevels, STopLevel (..), SAttribute (..), SDim (..), SOption (..),
SCases, SCase (..),
SProcs, SProc (..),
SProcPrototypes,
SProcPrototype (..),       -- $SProcPrototype
SArgDefs, SArgDef (..),
SType (..),
SProcRetType,              -- $SProcRetType
SInProcStmts, SInProcStmt (..),
SExprs, SExpr (..)
}
-- Imports
{
import Bscc.Symbol.Name (SymbolName)

import Prelude hiding (FilePath)
import System.Path (RelFile)
}


DERIVING *: Eq
DERIVING *: Show

DATA VtableIndex
   | VtableIndex  idx: Int

DATA SProject
   | SProject  modules: SModules  name: SymbolName

TYPE SModules = [SModule]

DATA SModule
   | SBasModule  path: RelFile  topLevel: STopLevels  name: SymbolName
   | SForm  path: RelFile  header: SNewClassHeader  topLevel: STopLevels  name: SymbolName

-- TODO: rename
DATA SNewClassHeader
   | SNewClassHeader  me: SNewClassHeaderBlock  children: SNewClassHeaderBlocks
-- FIXME: this should be a tuple of Parent, SNewClassHeaderBlock
-- (then listed).  So that children each have a parent.
TYPE SNewClassHeaderBlocks = [SNewClassHeaderBlock]
DATA SNewClassHeaderBlock
   -- FIXME: need name as well as classname
   | SNewClassHeaderBlock  classname: String  name: SymbolName  props: SNewProps
TYPE SNewProps = [SNewProp]
DATA SNewProp
   | SNewPropSimple  name: SymbolName  ty: SType  vtblIdx: VtableIndex  val: SExpr
   -- TODO: BeginProperty Font
-- FIXME terminology block vs is not is different plain vs withsem.

TYPE STopLevels = [STopLevel]

DATA STopLevel
   | SAttribute  attr: SAttribute
   | SDim  dim: SDim
   | SOption  option: SOption
   | SProc  proc: SProc

DATA SAttribute
   | SAttributeConstr

-- FIXME: why do I have this type instead of putting the data directlly on the STopLevel???????????? weird no?
-- maybe makes sense for dim if can dim elsewhere.  but for option explicit makes about zero sense.
DATA SDim
   | SDimConstr  name: SymbolName  ty: SType

DATA SOption
   | SOptionConstr

TYPE SProcs = [SProc]

DATA SProc
   | SProcConstr  proto: SProcPrototype  body: SInProcStmts

TYPE SProcPrototypes = [SProcPrototype]

{
-- $SProcPrototype
-- Although the language we compile has no prototypes for functions or
-- other procedures, pretend that it does.  Essentially, this structure
-- contains the non-body information about a procedure.
}
DATA SProcPrototype
   | SProcPrototype  name: SymbolName  argDefs: SArgDefs  retType: SProcRetType
                     -- Project and Module where the implementation of
                     -- the procedure resides.
                     implProject: SymbolName  implModule: SymbolName

-- This lets use {Data.Set.Set SProcPrototype}.
DERIVING SProcPrototype SArgDefs SArgDef SType: Eq, Ord

TYPE SArgDefs = [SArgDef]

DATA SArgDef
   | SArgDef  name: SymbolName  ty: SType

-- TODO: update in line with Expr
DATA SType
   | SBoolean
   | SDouble
   | SInteger
   | SLong
   | SString
   | SVariant

{
-- $SProcRetType
-- Return type of a procedure.  A `Bscc.Ast.Plain.Sub' has `Nothing'; a
-- Function would have the the appropriate @`Just' foo@.
}
TYPE SProcRetType = MAYBE SType

TYPE SInProcStmts = [SInProcStmt]

-- TODO: parity with Plain.ag
DATA SInProcStmt
   | SCall  proc: SProcPrototype  args: SExprs
   | SLet  var: SymbolName  expr: SExpr
   | SSelectCase  expr: SExpr  cases: SCases  default': SInProcStmts
   | SIf cond: SExpr  true: SInProcStmts  elseIfs: {[(SExpr, SInProcStmts)]}  false: SInProcStmts

TYPE SCases = [SCase]
DATA SCase
   | SSimple  expr: SExpr  stmts: SInProcStmts

TYPE SExprs = [SExpr]

-- TODO: update in line with Expr
DATA SExpr
   | SDoubleLit  val: Double  ty: SType
   | SStringLit  val: String  ty: SType
   | SIntegerLit  val: Integer  ty: SType -- TODO: finite val.  similarly for long
   | SLongLit  val: Integer  ty: SType
   | SIdentExpr  name: SymbolName  ty: SType
   | SAdd x: SExpr  y: SExpr  ty: SType
   | SMissing  ty: SType